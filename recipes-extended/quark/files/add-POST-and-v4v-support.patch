diff --git a/config.mk b/config.mk
index 7056241..3668565 100644
--- a/config.mk
+++ b/config.mk
@@ -4,13 +4,13 @@ VERSION = 0
 # Customize below to fit your system
 
 # paths
-PREFIX = /usr/local
+PREFIX = /usr
 MANPREFIX = $(PREFIX)/share/man
 
 # flags
 CPPFLAGS = -DVERSION=\"$(VERSION)\" -D_DEFAULT_SOURCE -D_XOPEN_SOURCE=700 -D_BSD_SOURCE
-CFLAGS   = -std=c99 -pedantic -Wall -Wextra -Os
-LDFLAGS  = -s
+CFLAGS   = -std=c99 -pedantic -Wall -Wextra -O
+LDFLAGS  =
 
 # compiler and linker
-CC = cc
+CC = gcc
diff --git a/http.c b/http.c
index 673e6eb..f456056 100644
--- a/http.c
+++ b/http.c
@@ -30,6 +30,7 @@ const char *req_field_str[] = {
 const char *req_method_str[] = {
 	[M_GET]  = "GET",
 	[M_HEAD] = "HEAD",
+	[M_POST] = "POST"
 };
 
 const char *status_str[] = {
@@ -119,14 +120,37 @@ http_get_request(int fd, struct request *r)
 		}
 	}
 
-	/* remove terminating empty line */
-	if (hlen < 2) {
+    /* split header and payload (if applicable)
+     *
+     *  expected POST format: HEADER,
+     *                        two newlines,
+     *                        PAYLOAD,
+     *                        two newlines
+     *
+     *  expected GET format: HEADER,
+     *                       two newlines
+     */
+
+    /* find first occurrence of double newlines */
+    p = strstr(h, "\r\n\r\n");
+	if (!p) {
 		return http_send_status(fd, S_BAD_REQUEST);
 	}
-	hlen -= 2;
 
-	/* null-terminate the header */
-	h[hlen] = '\0';
+    /* keep the first newline */
+    p += 2;
+
+    /* find second occurrence - if exists, POST request, else GET */
+    q = strstr(p, "\r\n\r\n");
+    if (q) {
+        *q = '\0';
+        strncpy(r->payload, p, q-p+1);
+    } else {
+        r->payload[0] = '\0';
+    }
+
+    /* null terminate header; strip second newline */
+    *p = '\0';
 
 	/*
 	 * parse request line
@@ -268,6 +292,8 @@ http_get_request(int fd, struct request *r)
 		memmove(r->field[REQ_HOST], p, q - p + 1);
 	}
 
+    /* wait until our fd is available for the next operation */
+    wait_fd_ready(fd, true, true);
 	return 0;
 }
 
@@ -353,7 +379,7 @@ http_send_response(int fd, struct request *r)
 	struct tm tm;
 	size_t len, i;
 	off_t lower, upper;
-	int hasport, ipv6host;
+	int hasport, ipv6host, ret;
 	static char realtarget[PATH_MAX], tmptarget[PATH_MAX], t[TIMESTAMP_LEN];
 	char *p, *q, *mime;
 	const char *vhostmatch, *targethost, *err;
@@ -602,5 +628,10 @@ http_send_response(int fd, struct request *r)
 		}
 	}
 
-	return resp_file(fd, RELPATH(realtarget), r, &st, mime, lower, upper);
+    /* wait until our fd is available for the next operation */
+    wait_fd_ready(fd, true, true);
+	ret = resp_file(fd, RELPATH(realtarget), r, &st, mime, lower, upper);
+    wait_fd_ready(fd, true, false);
+
+    return ret;
 }
diff --git a/http.h b/http.h
index cd1ba22..cfab3cf 100644
--- a/http.h
+++ b/http.h
@@ -5,6 +5,7 @@
 #include <limits.h>
 
 #define HEADER_MAX 4096
+#define PAYLOAD_MAX 8192
 #define FIELD_MAX 200
 
 enum req_field {
@@ -19,6 +20,7 @@ extern const char *req_field_str[];
 enum req_method {
 	M_GET,
 	M_HEAD,
+    M_POST,
 	NUM_REQ_METHODS,
 };
 
@@ -28,6 +30,7 @@ struct request {
 	enum req_method method;
 	char target[PATH_MAX];
 	char field[NUM_REQ_FIELDS][FIELD_MAX];
+    char payload[PAYLOAD_MAX];
 };
 
 enum status {
diff --git a/main.c b/main.c
index e9d0a06..bbf3320 100644
--- a/main.c
+++ b/main.c
@@ -13,6 +13,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <syslog.h>
 #include <time.h>
 #include <unistd.h>
 
@@ -31,14 +32,17 @@ serve(int infd, struct sockaddr_storage *in_sa)
 	char inaddr[INET6_ADDRSTRLEN /* > INET_ADDRSTRLEN */];
 	char tstmp[21];
 
-	/* set connection timeout */
-	if (sock_set_timeout(infd, 30)) {
-		goto cleanup;
-	}
-
 	/* handle request */
-	if (!(status = http_get_request(infd, &r))) {
-		status = http_send_response(infd, &r);
+    status = http_get_request(infd, &r);
+
+	if (!status) {
+        if (r.method == M_POST) {
+            /* handle POST */
+            syslog(LOG_INFO, "[quark] %s", r.payload);
+        } else {
+            /* handle GET */
+		    status = http_send_response(infd, &r);
+        }
 	}
 
 	/* write output to log */
diff --git a/resp.c b/resp.c
index 3075c28..197bb3c 100644
--- a/resp.c
+++ b/resp.c
@@ -141,6 +141,7 @@ resp_file(int fd, char *name, struct request *r, struct stat *st, char *mime,
 	            "Date: %s\r\n"
 	            "Connection: close\r\n"
 	            "Last-Modified: %s\r\n"
+                "Expires: Wed, 1 Jan 2030 00:00:00 GMT\r\n"
 	            "Content-Type: %s\r\n"
 	            "Content-Length: %zu\r\n",
 	            s, status_str[s], timestamp(time(NULL), t1),
diff --git a/util.c b/util.c
index 0b05d91..d756d48 100644
--- a/util.c
+++ b/util.c
@@ -133,3 +133,27 @@ reallocarray(void *optr, size_t nmemb, size_t size)
 	}
 	return realloc(optr, size * nmemb);
 }
+
+void
+wait_fd_ready(int fd, bool read, bool write)
+{
+    struct timeval tv;
+    fd_set readfds;
+    fd_set writefds;
+
+    tv.tv_sec = 0;
+    tv.tv_usec = 500000;
+
+    FD_ZERO(&readfds);
+    FD_ZERO(&writefds);
+
+    if (read) {
+        FD_SET(fd, &readfds);
+    }
+
+    if (write) {
+        FD_SET(fd, &writefds);
+    }
+
+    select(fd + 1, &readfds, &writefds, NULL, &tv);
+}
diff --git a/util.h b/util.h
index 12b7bd8..d41dc40 100644
--- a/util.h
+++ b/util.h
@@ -3,6 +3,7 @@
 #define UTIL_H
 
 #include <regex.h>
+#include <stdbool.h>
 #include <stddef.h>
 #include <time.h>
 
@@ -54,4 +55,6 @@ int esnprintf(char *, size_t, const char *, ...);
 void *reallocarray(void *, size_t, size_t);
 long long strtonum(const char *, long long, long long, const char **);
 
+void wait_fd_ready(int, bool, bool);
+
 #endif /* UTIL_H */
